// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: src/github.com/harrizontal/dispatchserver/dispatchsim/driveragent.go

package dispatchsim

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *DriverAgent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *DriverAgent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.S != nil {
		buf.WriteString(`{"S":`)

		{

			err = j.S.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`{"S":null`)
	}
	if j.E != nil {
		/* Struct fall back. type=dispatchsim.Environment kind=struct */
		buf.WriteString(`,"E":`)
		err = buf.Encode(j.E)
		if err != nil {
			return err
		}
	} else {
		buf.WriteString(`,"E":null`)
	}
	buf.WriteString(`,"Id":`)
	fflib.FormatBits2(buf, uint64(j.Id), 10, j.Id < 0)
	buf.WriteString(`,"Name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	/* Struct fall back. type=dispatchsim.LatLng kind=struct */
	buf.WriteString(`,"CurrentLocation":`)
	err = buf.Encode(&j.CurrentLocation)
	if err != nil {
		return err
	}
	buf.WriteString(`,"Waypoint":`)
	if j.Waypoint != nil {
		buf.WriteString(`[`)
		for i, v := range j.Waypoint {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Struct fall back. type=dispatchsim.LatLng kind=struct */
			err = buf.Encode(&v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	/* Struct fall back. type=dispatchsim.LatLng kind=struct */
	buf.WriteString(`,"NextLocation":`)
	err = buf.Encode(&j.NextLocation)
	if err != nil {
		return err
	}
	/* Struct fall back. type=dispatchsim.LatLng kind=struct */
	buf.WriteString(`,"DestinationLocation":`)
	err = buf.Encode(&j.DestinationLocation)
	if err != nil {
		return err
	}
	/* Struct fall back. type=dispatchsim.Task kind=struct */
	buf.WriteString(`,"PendingTask":`)
	err = buf.Encode(&j.PendingTask)
	if err != nil {
		return err
	}
	/* Struct fall back. type=dispatchsim.Task kind=struct */
	buf.WriteString(`,"CurrentTask":`)
	err = buf.Encode(&j.CurrentTask)
	if err != nil {
		return err
	}
	buf.WriteString(`,"Status":`)
	fflib.FormatBits2(buf, uint64(j.Status), 10, j.Status < 0)
	buf.WriteString(`,"Request":`)
	/* Falling back. type=chan dispatchsim.Message kind=chan */
	err = buf.Encode(j.Request)
	if err != nil {
		return err
	}
	buf.WriteString(`,"Recieve":`)
	/* Falling back. type=chan dispatchsim.Message kind=chan */
	err = buf.Encode(j.Recieve)
	if err != nil {
		return err
	}
	buf.WriteString(`,"Recieve2":`)
	/* Falling back. type=chan int kind=chan */
	err = buf.Encode(j.Recieve2)
	if err != nil {
		return err
	}
	buf.WriteString(`,"RecieveNewRoute":`)
	/* Falling back. type=chan []dispatchsim.LatLng kind=chan */
	err = buf.Encode(j.RecieveNewRoute)
	if err != nil {
		return err
	}
	if j.RequestNewRoute {
		buf.WriteString(`,"RequestNewRoute":true`)
	} else {
		buf.WriteString(`,"RequestNewRoute":false`)
	}
	buf.WriteString(`,"Send":`)
	/* Falling back. type=chan string kind=chan */
	err = buf.Encode(j.Send)
	if err != nil {
		return err
	}
	buf.WriteString(`,"TasksCompleted":`)
	fflib.FormatBits2(buf, uint64(j.TasksCompleted), 10, j.TasksCompleted < 0)
	buf.WriteString(`,"TaskHistory":`)
	if j.TaskHistory != nil {
		buf.WriteString(`[`)
		for i, v := range j.TaskHistory {
			if i != 0 {
				buf.WriteString(`,`)
			}
			/* Struct fall back. type=dispatchsim.Task kind=struct */
			err = buf.Encode(&v)
			if err != nil {
				return err
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"Motivation":`)
	fflib.AppendFloat(buf, float64(j.Motivation), 'g', -1, 64)
	buf.WriteString(`,"Reputation":`)
	fflib.AppendFloat(buf, float64(j.Reputation), 'g', -1, 64)
	buf.WriteString(`,"Fatigue":`)
	fflib.AppendFloat(buf, float64(j.Fatigue), 'g', -1, 64)
	buf.WriteString(`,"Regret":`)
	fflib.AppendFloat(buf, float64(j.Regret), 'g', -1, 64)
	buf.WriteString(`,"ChangeDestination":`)
	/* Falling back. type=chan string kind=chan */
	err = buf.Encode(j.ChangeDestination)
	if err != nil {
		return err
	}
	buf.WriteString(`,"StartDriving":`)

	{

		obj, err = j.StartDriving.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"EndDriving":`)

	{

		obj, err = j.EndDriving.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	if j.Valid {
		buf.WriteString(`,"Valid":true`)
	} else {
		buf.WriteString(`,"Valid":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtDriverAgentbase = iota
	ffjtDriverAgentnosuchkey

	ffjtDriverAgentS

	ffjtDriverAgentE

	ffjtDriverAgentId

	ffjtDriverAgentName

	ffjtDriverAgentCurrentLocation

	ffjtDriverAgentWaypoint

	ffjtDriverAgentNextLocation

	ffjtDriverAgentDestinationLocation

	ffjtDriverAgentPendingTask

	ffjtDriverAgentCurrentTask

	ffjtDriverAgentStatus

	ffjtDriverAgentRequest

	ffjtDriverAgentRecieve

	ffjtDriverAgentRecieve2

	ffjtDriverAgentRecieveNewRoute

	ffjtDriverAgentRequestNewRoute

	ffjtDriverAgentSend

	ffjtDriverAgentTasksCompleted

	ffjtDriverAgentTaskHistory

	ffjtDriverAgentMotivation

	ffjtDriverAgentReputation

	ffjtDriverAgentFatigue

	ffjtDriverAgentRegret

	ffjtDriverAgentChangeDestination

	ffjtDriverAgentStartDriving

	ffjtDriverAgentEndDriving

	ffjtDriverAgentValid
)

var ffjKeyDriverAgentS = []byte("S")

var ffjKeyDriverAgentE = []byte("E")

var ffjKeyDriverAgentId = []byte("Id")

var ffjKeyDriverAgentName = []byte("Name")

var ffjKeyDriverAgentCurrentLocation = []byte("CurrentLocation")

var ffjKeyDriverAgentWaypoint = []byte("Waypoint")

var ffjKeyDriverAgentNextLocation = []byte("NextLocation")

var ffjKeyDriverAgentDestinationLocation = []byte("DestinationLocation")

var ffjKeyDriverAgentPendingTask = []byte("PendingTask")

var ffjKeyDriverAgentCurrentTask = []byte("CurrentTask")

var ffjKeyDriverAgentStatus = []byte("Status")

var ffjKeyDriverAgentRequest = []byte("Request")

var ffjKeyDriverAgentRecieve = []byte("Recieve")

var ffjKeyDriverAgentRecieve2 = []byte("Recieve2")

var ffjKeyDriverAgentRecieveNewRoute = []byte("RecieveNewRoute")

var ffjKeyDriverAgentRequestNewRoute = []byte("RequestNewRoute")

var ffjKeyDriverAgentSend = []byte("Send")

var ffjKeyDriverAgentTasksCompleted = []byte("TasksCompleted")

var ffjKeyDriverAgentTaskHistory = []byte("TaskHistory")

var ffjKeyDriverAgentMotivation = []byte("Motivation")

var ffjKeyDriverAgentReputation = []byte("Reputation")

var ffjKeyDriverAgentFatigue = []byte("Fatigue")

var ffjKeyDriverAgentRegret = []byte("Regret")

var ffjKeyDriverAgentChangeDestination = []byte("ChangeDestination")

var ffjKeyDriverAgentStartDriving = []byte("StartDriving")

var ffjKeyDriverAgentEndDriving = []byte("EndDriving")

var ffjKeyDriverAgentValid = []byte("Valid")

// UnmarshalJSON umarshall json - template of ffjson
func (j *DriverAgent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *DriverAgent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtDriverAgentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtDriverAgentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'C':

					if bytes.Equal(ffjKeyDriverAgentCurrentLocation, kn) {
						currentKey = ffjtDriverAgentCurrentLocation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentCurrentTask, kn) {
						currentKey = ffjtDriverAgentCurrentTask
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentChangeDestination, kn) {
						currentKey = ffjtDriverAgentChangeDestination
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'D':

					if bytes.Equal(ffjKeyDriverAgentDestinationLocation, kn) {
						currentKey = ffjtDriverAgentDestinationLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'E':

					if bytes.Equal(ffjKeyDriverAgentE, kn) {
						currentKey = ffjtDriverAgentE
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentEndDriving, kn) {
						currentKey = ffjtDriverAgentEndDriving
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'F':

					if bytes.Equal(ffjKeyDriverAgentFatigue, kn) {
						currentKey = ffjtDriverAgentFatigue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'I':

					if bytes.Equal(ffjKeyDriverAgentId, kn) {
						currentKey = ffjtDriverAgentId
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'M':

					if bytes.Equal(ffjKeyDriverAgentMotivation, kn) {
						currentKey = ffjtDriverAgentMotivation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'N':

					if bytes.Equal(ffjKeyDriverAgentName, kn) {
						currentKey = ffjtDriverAgentName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentNextLocation, kn) {
						currentKey = ffjtDriverAgentNextLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyDriverAgentPendingTask, kn) {
						currentKey = ffjtDriverAgentPendingTask
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'R':

					if bytes.Equal(ffjKeyDriverAgentRequest, kn) {
						currentKey = ffjtDriverAgentRequest
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentRecieve, kn) {
						currentKey = ffjtDriverAgentRecieve
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentRecieve2, kn) {
						currentKey = ffjtDriverAgentRecieve2
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentRecieveNewRoute, kn) {
						currentKey = ffjtDriverAgentRecieveNewRoute
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentRequestNewRoute, kn) {
						currentKey = ffjtDriverAgentRequestNewRoute
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentReputation, kn) {
						currentKey = ffjtDriverAgentReputation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentRegret, kn) {
						currentKey = ffjtDriverAgentRegret
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyDriverAgentS, kn) {
						currentKey = ffjtDriverAgentS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentStatus, kn) {
						currentKey = ffjtDriverAgentStatus
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentSend, kn) {
						currentKey = ffjtDriverAgentSend
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentStartDriving, kn) {
						currentKey = ffjtDriverAgentStartDriving
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'T':

					if bytes.Equal(ffjKeyDriverAgentTasksCompleted, kn) {
						currentKey = ffjtDriverAgentTasksCompleted
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDriverAgentTaskHistory, kn) {
						currentKey = ffjtDriverAgentTaskHistory
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'V':

					if bytes.Equal(ffjKeyDriverAgentValid, kn) {
						currentKey = ffjtDriverAgentValid
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'W':

					if bytes.Equal(ffjKeyDriverAgentWaypoint, kn) {
						currentKey = ffjtDriverAgentWaypoint
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentValid, kn) {
					currentKey = ffjtDriverAgentValid
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentEndDriving, kn) {
					currentKey = ffjtDriverAgentEndDriving
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDriverAgentStartDriving, kn) {
					currentKey = ffjtDriverAgentStartDriving
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDriverAgentChangeDestination, kn) {
					currentKey = ffjtDriverAgentChangeDestination
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentRegret, kn) {
					currentKey = ffjtDriverAgentRegret
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentFatigue, kn) {
					currentKey = ffjtDriverAgentFatigue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentReputation, kn) {
					currentKey = ffjtDriverAgentReputation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentMotivation, kn) {
					currentKey = ffjtDriverAgentMotivation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDriverAgentTaskHistory, kn) {
					currentKey = ffjtDriverAgentTaskHistory
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDriverAgentTasksCompleted, kn) {
					currentKey = ffjtDriverAgentTasksCompleted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDriverAgentSend, kn) {
					currentKey = ffjtDriverAgentSend
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDriverAgentRequestNewRoute, kn) {
					currentKey = ffjtDriverAgentRequestNewRoute
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentRecieveNewRoute, kn) {
					currentKey = ffjtDriverAgentRecieveNewRoute
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyDriverAgentRecieve2, kn) {
					currentKey = ffjtDriverAgentRecieve2
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentRecieve, kn) {
					currentKey = ffjtDriverAgentRecieve
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDriverAgentRequest, kn) {
					currentKey = ffjtDriverAgentRequest
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDriverAgentStatus, kn) {
					currentKey = ffjtDriverAgentStatus
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDriverAgentCurrentTask, kn) {
					currentKey = ffjtDriverAgentCurrentTask
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDriverAgentPendingTask, kn) {
					currentKey = ffjtDriverAgentPendingTask
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDriverAgentDestinationLocation, kn) {
					currentKey = ffjtDriverAgentDestinationLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentNextLocation, kn) {
					currentKey = ffjtDriverAgentNextLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentWaypoint, kn) {
					currentKey = ffjtDriverAgentWaypoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentCurrentLocation, kn) {
					currentKey = ffjtDriverAgentCurrentLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentName, kn) {
					currentKey = ffjtDriverAgentName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentId, kn) {
					currentKey = ffjtDriverAgentId
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDriverAgentE, kn) {
					currentKey = ffjtDriverAgentE
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyDriverAgentS, kn) {
					currentKey = ffjtDriverAgentS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtDriverAgentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtDriverAgentS:
					goto handle_S

				case ffjtDriverAgentE:
					goto handle_E

				case ffjtDriverAgentId:
					goto handle_Id

				case ffjtDriverAgentName:
					goto handle_Name

				case ffjtDriverAgentCurrentLocation:
					goto handle_CurrentLocation

				case ffjtDriverAgentWaypoint:
					goto handle_Waypoint

				case ffjtDriverAgentNextLocation:
					goto handle_NextLocation

				case ffjtDriverAgentDestinationLocation:
					goto handle_DestinationLocation

				case ffjtDriverAgentPendingTask:
					goto handle_PendingTask

				case ffjtDriverAgentCurrentTask:
					goto handle_CurrentTask

				case ffjtDriverAgentStatus:
					goto handle_Status

				case ffjtDriverAgentRequest:
					goto handle_Request

				case ffjtDriverAgentRecieve:
					goto handle_Recieve

				case ffjtDriverAgentRecieve2:
					goto handle_Recieve2

				case ffjtDriverAgentRecieveNewRoute:
					goto handle_RecieveNewRoute

				case ffjtDriverAgentRequestNewRoute:
					goto handle_RequestNewRoute

				case ffjtDriverAgentSend:
					goto handle_Send

				case ffjtDriverAgentTasksCompleted:
					goto handle_TasksCompleted

				case ffjtDriverAgentTaskHistory:
					goto handle_TaskHistory

				case ffjtDriverAgentMotivation:
					goto handle_Motivation

				case ffjtDriverAgentReputation:
					goto handle_Reputation

				case ffjtDriverAgentFatigue:
					goto handle_Fatigue

				case ffjtDriverAgentRegret:
					goto handle_Regret

				case ffjtDriverAgentChangeDestination:
					goto handle_ChangeDestination

				case ffjtDriverAgentStartDriving:
					goto handle_StartDriving

				case ffjtDriverAgentEndDriving:
					goto handle_EndDriving

				case ffjtDriverAgentValid:
					goto handle_Valid

				case ffjtDriverAgentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_S:

	/* handler: j.S type=dispatchsim.Simulation kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.S = nil

		} else {

			if j.S == nil {
				j.S = new(Simulation)
			}

			err = j.S.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_E:

	/* handler: j.E type=dispatchsim.Environment kind=struct quoted=false*/

	{
		/* Falling back. type=dispatchsim.Environment kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.E)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Id:

	/* handler: j.Id type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Id = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentLocation:

	/* handler: j.CurrentLocation type=dispatchsim.LatLng kind=struct quoted=false*/

	{
		/* Falling back. type=dispatchsim.LatLng kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.CurrentLocation)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Waypoint:

	/* handler: j.Waypoint type=[]dispatchsim.LatLng kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Waypoint = nil
		} else {

			j.Waypoint = []LatLng{}

			wantVal := true

			for {

				var tmpJWaypoint LatLng

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJWaypoint type=dispatchsim.LatLng kind=struct quoted=false*/

				{
					/* Falling back. type=dispatchsim.LatLng kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJWaypoint)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.Waypoint = append(j.Waypoint, tmpJWaypoint)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NextLocation:

	/* handler: j.NextLocation type=dispatchsim.LatLng kind=struct quoted=false*/

	{
		/* Falling back. type=dispatchsim.LatLng kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.NextLocation)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DestinationLocation:

	/* handler: j.DestinationLocation type=dispatchsim.LatLng kind=struct quoted=false*/

	{
		/* Falling back. type=dispatchsim.LatLng kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.DestinationLocation)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PendingTask:

	/* handler: j.PendingTask type=dispatchsim.Task kind=struct quoted=false*/

	{
		/* Falling back. type=dispatchsim.Task kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.PendingTask)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentTask:

	/* handler: j.CurrentTask type=dispatchsim.Task kind=struct quoted=false*/

	{
		/* Falling back. type=dispatchsim.Task kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.CurrentTask)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Status:

	/* handler: j.Status type=dispatchsim.DriverStatus kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for DriverStatus", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Status = DriverStatus(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Request:

	/* handler: j.Request type=chan dispatchsim.Message kind=chan quoted=false*/

	{
		/* Falling back. type=chan dispatchsim.Message kind=chan */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Request)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Recieve:

	/* handler: j.Recieve type=chan dispatchsim.Message kind=chan quoted=false*/

	{
		/* Falling back. type=chan dispatchsim.Message kind=chan */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Recieve)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Recieve2:

	/* handler: j.Recieve2 type=chan int kind=chan quoted=false*/

	{
		/* Falling back. type=chan int kind=chan */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Recieve2)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RecieveNewRoute:

	/* handler: j.RecieveNewRoute type=chan []dispatchsim.LatLng kind=chan quoted=false*/

	{
		/* Falling back. type=chan []dispatchsim.LatLng kind=chan */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.RecieveNewRoute)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestNewRoute:

	/* handler: j.RequestNewRoute type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestNewRoute = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestNewRoute = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Send:

	/* handler: j.Send type=chan string kind=chan quoted=false*/

	{
		/* Falling back. type=chan string kind=chan */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Send)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TasksCompleted:

	/* handler: j.TasksCompleted type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TasksCompleted = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_TaskHistory:

	/* handler: j.TaskHistory type=[]dispatchsim.Task kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.TaskHistory = nil
		} else {

			j.TaskHistory = []Task{}

			wantVal := true

			for {

				var tmpJTaskHistory Task

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJTaskHistory type=dispatchsim.Task kind=struct quoted=false*/

				{
					/* Falling back. type=dispatchsim.Task kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJTaskHistory)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.TaskHistory = append(j.TaskHistory, tmpJTaskHistory)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Motivation:

	/* handler: j.Motivation type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Motivation = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Reputation:

	/* handler: j.Reputation type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Reputation = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Fatigue:

	/* handler: j.Fatigue type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Fatigue = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Regret:

	/* handler: j.Regret type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Regret = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChangeDestination:

	/* handler: j.ChangeDestination type=chan string kind=chan quoted=false*/

	{
		/* Falling back. type=chan string kind=chan */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ChangeDestination)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartDriving:

	/* handler: j.StartDriving type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.StartDriving.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EndDriving:

	/* handler: j.EndDriving type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.EndDriving.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Valid:

	/* handler: j.Valid type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Valid = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Valid = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
